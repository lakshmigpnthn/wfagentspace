import unittest
from unittest.mock import patch, MagicMock, mock_open
import os
import sys
import json

# Import the module to test (assuming it's in a file called runbook_generator.py)
# If you have a different filename, update this import
from runbook import create_runbook_from_steps, generate_with_gemini

class TestRunbookGenerator(unittest.TestCase):
    """Test cases for the runbook generator functionality."""
    
    def setUp(self):
        """Set up test environment before each test."""
        # Save any existing environment variables to restore later
        self.original_openai_key = os.environ.get("OPENAI_API_KEY")
        self.original_google_key = os.environ.get("GOOGLE_API_KEY")
        
        # Test data
        self.test_issue = """
        Issue: Test Server Issue
        Description: This is a test issue
        Fix Steps:
        1. Step one
        2. Step two
        """
        self.test_output_file = "test_runbook.md"
        
    def tearDown(self):
        """Clean up after each test."""
        # Restore original environment variables
        if self.original_openai_key:
            os.environ["OPENAI_API_KEY"] = self.original_openai_key
        else:
            os.environ.pop("OPENAI_API_KEY", None)
            
        if self.original_google_key:
            os.environ["GOOGLE_API_KEY"] = self.original_google_key
        else:
            os.environ.pop("GOOGLE_API_KEY", None)
            
        # Remove test file if it exists
        if os.path.exists(self.test_output_file):
            os.remove(self.test_output_file)

    @patch("runbook_generator.autogen.UserProxyAgent")
    @patch("runbook_generator.autogen.AssistantAgent")
    @patch("runbook_generator.autogen.GroupChat")
    @patch("runbook_generator.autogen.GroupChatManager")
    @patch("builtins.open", new_callable=mock_open)
    def test_successful_runbook_creation_with_autogen(self, mock_file, mock_manager, mock_groupchat, 
                                                     mock_assistant, mock_user_proxy):
        """Test successful runbook creation using AutoGen agents."""
        # Mock the UserProxyAgent initiate_chat method
        mock_user_instance = MagicMock()
        mock_user_proxy.return_value = mock_user_instance
        
        # Mock the GroupChat messages
        mock_groupchat_instance = MagicMock()
        mock_groupchat.return_value = mock_groupchat_instance
        mock_groupchat_instance.messages = [
            {"sender": "Formatter", "content": "```markdown\n# Test Runbook\nThis is a mock runbook.\n```"}
        ]
        
        # Mock the GroupChatManager
        mock_manager_instance = MagicMock()
        mock_manager.return_value = mock_manager_instance
        
        # Call the function
        result = create_runbook_from_steps(
            issue_description=self.test_issue,
            output_file=self.test_output_file,
            openai_api_key="test-openai-key"
        )
        
        # Assert environment variable was set
        self.assertEqual(os.environ.get("OPENAI_API_KEY"), "test-openai-key")
        
        # Assert UserProxyAgent was initialized correctly
        mock_user_proxy.assert_called_once()
        self.assertTrue("User" in str(mock_user_proxy.call_args))
        
        # Assert AssistantAgent was initialized multiple times (for different agents)
        self.assertGreaterEqual(mock_assistant.call_count, 3)
        
        # Assert GroupChat was initialized
        mock_groupchat.assert_called_once()
        
        # Assert chat was initiated
        mock_user_instance.initiate_chat.assert_called_once()
        self.assertTrue(self.test_issue in str(mock_user_instance.initiate_chat.call_args))
        
        # Assert file was written to
        mock_file.assert_called_once_with(self.test_output_file, "w")
        mock_file().write.assert_called_once_with("# Test Runbook\nThis is a mock runbook.")
        
        # Assert correct return value
        self.assertEqual(result, self.test_output_file)

    @patch("runbook_generator.autogen.UserProxyAgent")
    @patch("runbook_generator.autogen.GroupChat")
    @patch("runbook_generator.generate_with_gemini")
    @patch("builtins.open", new_callable=mock_open)
    def test_fallback_to_gemini_when_autogen_fails(self, mock_file, mock_gemini, mock_groupchat, mock_user_proxy):
        """Test fallback to Gemini when AutoGen processing fails."""
        # Set up the UserProxyAgent to raise an exception
        mock_user_instance = MagicMock()
        mock_user_proxy.return_value = mock_user_instance
        mock_user_instance.initiate_chat.side_effect = Exception("AutoGen error")
        
        # Configure the Gemini fallback to return a specific string
        mock_gemini.return_value = "# Fallback Runbook\nGenerated by Gemini"
        
        # Call the function
        result = create_runbook_from_steps(
            issue_description=self.test_issue,
            output_file=self.test_output_file,
            openai_api_key="test-openai-key",
            gemini_api_key="test-gemini-key"
        )
        
        # Assert Gemini was called
        mock_gemini.assert_called_once_with(self.test_issue)
        
        # Assert file was written with Gemini's output
        mock_file.assert_called_once_with(self.test_output_file, "w")
        mock_file().write.assert_called_once_with("# Fallback Runbook\nGenerated by Gemini")
        
        # Assert correct return value
        self.assertEqual(result, self.test_output_file)

    @patch("runbook_generator.genai")
    @patch("builtins.open", new_callable=mock_open)
    def test_gemini_direct_generation(self, mock_file, mock_genai):
        """Test the direct Gemini generation function."""
        # Configure the environment and mock response
        os.environ["GOOGLE_API_KEY"] = "test-gemini-key"
        
        mock_genai_model = MagicMock()
        mock_genai.GenerativeModel.return_value = mock_genai_model
        
        mock_response = MagicMock()
        mock_response.text = "# Gemini Generated Runbook\nContent here"
        mock_genai_model.generate_content.return_value = mock_response
        
        # Call the function
        result = generate_with_gemini(self.test_issue)
        
        # Assert genai was configured
        mock_genai.configure.assert_called_once_with(api_key="test-gemini-key")
        
        # Assert GenerativeModel was created with correct parameters
        mock_genai.GenerativeModel.assert_called_once()
        self.assertEqual(mock_genai.GenerativeModel.call_args[1]["model_name"], "gemini-1.5-pro")
        
        # Assert generate_content was called with the issue description
        mock_genai_model.generate_content.assert_called_once()
        self.assertTrue(self.test_issue in str(mock_genai_model.generate_content.call_args[0][0]))
        
        # Assert the correct result is returned
        self.assertEqual(result, "# Gemini Generated Runbook\nContent here")

    @patch("builtins.open", new_callable=mock_open)
    def test_error_when_no_api_keys_provided(self, mock_file):
        """Test that an error is raised when no API keys are provided."""
        # Ensure environment variables are cleared
        if "OPENAI_API_KEY" in os.environ:
            del os.environ["OPENAI_API_KEY"]
        
        # Call the function and expect ValueError
        with self.assertRaises(ValueError) as context:
            create_runbook_from_steps(
                issue_description=self.test_issue,
                output_file=self.test_output_file
            )
        
        # Check the error message
        self.assertTrue("OpenAI API key not provided" in str(context.exception))
        
        # Assert file was not written
        mock_file.assert_not_called()

    @patch("runbook_generator.autogen.UserProxyAgent")
    @patch("runbook_generator.autogen.GroupChat")
    @patch("runbook_generator.generate_with_gemini")
    @patch("builtins.open", new_callable=mock_open)
    def test_empty_runbook_handling(self, mock_file, mock_gemini, mock_groupchat, mock_user_proxy):
        """Test handling when no runbook content is found in the messages."""
        # Set up GroupChat with no valid runbook messages
        mock_groupchat_instance = MagicMock()
        mock_groupchat.return_value = mock_groupchat_instance
        mock_groupchat_instance.messages = [
            {"sender": "User", "content": "Hello"},
            {"sender": "Analyst", "content": "I'm analyzing"}
            # No Formatter or RunbookWriter messages
        ]
        
        # Make Gemini fallback also fail
        mock_gemini.return_value = None
        
        # Call the function
        result = create_runbook_from_steps(
            issue_description=self.test_issue,
            output_file=self.test_output_file,
            openai_api_key="test-openai-key"
        )
        
        # Assert default error message was written
        mock_file.assert_called_once_with(self.test_output_file, "w")
        mock_file().write.assert_called_once()
        written_content = mock_file().write.call_args[0][0]
        self.assertTrue("# Error" in written_content)
        self.assertTrue("No runbook was successfully generated" in written_content)
        
        # Assert correct return value
        self.assertEqual(result, self.test_output_file)

    @patch("runbook_generator.autogen.UserProxyAgent")
    @patch("runbook_generator.autogen.AssistantAgent")
    @patch("runbook_generator.autogen.GroupChat")
    @patch("runbook_generator.autogen.GroupChatManager")
    @patch("builtins.open", new_callable=mock_open)
    def test_extract_markdown_from_code_block(self, mock_file, mock_manager, mock_groupchat, 
                                             mock_assistant, mock_user_proxy):
        """Test extracting markdown content from code blocks in agent messages."""
        # Set up GroupChat with markdown content in code blocks
        mock_groupchat_instance = MagicMock()
        mock_groupchat.return_value = mock_groupchat_instance
        mock_groupchat_instance.messages = [
            {"sender": "Formatter", "content": "Here's the formatted runbook:\n```markdown\n# Test Runbook\nWith markdown content\n```"}
        ]
        
        # Call the function
        result = create_runbook_from_steps(
            issue_description=self.test_issue,
            output_file=self.test_output_file,
            openai_api_key="test-openai-key"
        )
        
        # Assert correct content was extracted and written
        mock_file.assert_called_once_with(self.test_output_file, "w")
        mock_file().write.assert_called_once_with("# Test Runbook\nWith markdown content")
        
        # Assert correct return value
        self.assertEqual(result, self.test_output_file)


if __name__ == '__main__':
    unittest.main()